Index: lib/session-file-helpers.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/session-file-helpers.js	(revision )
+++ lib/session-file-helpers.js	(revision )
@@ -0,0 +1,242 @@
+var fs = require('graceful-fs'),
+  path = require('path'),
+  retry = require('retry'),
+  childProcess = require('child_process');
+
+var helpers = {
+
+  sessionPath: function (path, sessionId) {
+    return path.join(path, sessionId + '.json');
+  },
+
+  sessionId: function (file) {
+    return file.substring(0, file.lastIndexOf('.json'));
+  },
+
+  defaults: function (options) {
+    return {
+      path: path.normalize(options.path || './sessions'),
+      ttl: options.ttl || 3600,
+      retries: options.retries || 5,
+      factor: options.factor || 1,
+      minTimeout: options.minTimeout || 50,
+      maxTimeout: options.maxTimeout || 100,
+      filePattern: /\.json$/,
+      reapInterval: options.reapInterval || 3600
+    };
+  },
+
+  createPathIfRequired: function (options) {
+    fs.mkdir(options.path, function (err) {
+      if (err && err.code != 'EEXIST') throw err;
+    });
+  },
+
+  destroyIfExpired: function (sessionId, options) {
+    helpers.expired(sessionId, options, function (err, expired) {
+      if (err == null && expired) {
+        helpers.destroy(sessionId, options);
+      }
+    });
+  },
+
+  scheduleReapWorker: function (options) {
+    if (options.reapInterval !== -1) {
+      setInterval(function () {
+        console.log("[session-file-store] Starting reap worker thread");
+        childProcess.execFile('reap-worker.js', [options.path, options.ttl]);
+
+        helpers.reap();
+      }, options.reapInterval * 1000);
+    }
+  },
+
+  reap: function (options) {
+    helpers.list(options, function (err, files) {
+      if (err == null) {
+        for (var i = 0; i < files.length; ++i) {
+          helpers.destroyIfExpired(helpers.sessionId(files[i]), options);
+        }
+      }
+    });
+  },
+
+  /**
+   * Attempts to fetch session from a session file by the given `sessionId`
+   *
+   * @param  {String}   sessionId
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  get: function (sessionId, options, callback) {
+    var sessionPath = helpers.sessionPath(options.path, sessionId);
+
+    var operation = retry.operation({
+      retries: options.retries,
+      factor: options.factor,
+      minTimeout: options.minTimeout,
+      maxTimeout: options.maxTimeout
+    });
+
+    operation.attempt(function () {
+      fs.readFile(sessionPath, 'utf8', function (err, data) {
+        if (err) return callback(err);
+
+        var json;
+        try {
+          json = JSON.parse(data);
+        } catch (err) {
+          if (operation.retry(err)) {
+            console.log("[session-file-store] will retry, error on last attempt: " + err);
+          } else {
+            callback(err);
+          }
+          return;
+        }
+        callback(null, json);
+      });
+    });
+  },
+
+  /**
+   * Attempts to commit the given `session` associated with the given `sessionId` to a session file
+   *
+   * @param {String}   sessionId
+   * @param {Object}   session
+   * @param  {Object}  options
+   * @param {Function} callback   optional
+   *
+   * @api public
+   */
+  set: function (sessionId, session, options, callback) {
+    try {
+      session.__lastAccess = new Date().getTime();
+
+      var sessionPath = helpers.sessionPath(options.path, sessionId);
+      var data = JSON.stringify(session);
+      fs.writeFile(sessionPath, data, function (err) {
+        callback && err ? callback(err) : callback(null, session);
+      });
+    } catch (err) {
+      if (callback) callback(err);
+    }
+  },
+
+  /**
+   * Attempts to unlink a given session by its id
+   *
+   * @param  {String}   sessionId   Files are serialized to disk by their sessionId
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  destroy: function (sessionId, options, callback) {
+    var sessionPath = helpers.sessionPath(options.path, sessionId);
+    fs.unlink(sessionPath, function (err) {
+      if (callback) callback(err);
+    });
+  },
+
+  /**
+   * Attempts to fetch number of the session files
+   *
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  length: function (options, callback) {
+    fs.readdir(options.path, function (err, files) {
+      if (err) return callback(err);
+
+      var result = 0;
+      files.forEach(function (file) {
+        if (options.filePattern.exec(file)) {
+          ++result;
+        }
+      });
+
+      callback(null, result);
+    });
+  },
+
+  /**
+   * Attempts to clear out all of the existing session files
+   *
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  clear: function (options, callback) {
+    fs.readdir(options.path, function (err, files) {
+      if (files.length <= 0) return callback();
+
+      var errors = [];
+      files.forEach(function (file, i) {
+        if (options.filePattern.exec(file)) {
+          fs.unlink(path.join(options.path, file), function (err) {
+            if (err) {
+              errors.push(err);
+            }
+            if (i >= files.length - 1) {
+              callback(errors.length > 0 ? errors : undefined);
+            }
+          });
+        } else {
+          if (i >= files.length - 1) {
+            callback(errors.length > 0 ? errors : undefined);
+          }
+        }
+      });
+    });
+  },
+
+  /**
+   * Attempts to find all of the session files
+   *
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  list: function (options, callback) {
+    fs.readdir(options.path, function (err, files) {
+      if (err) return callback(err);
+
+      files = files.filter(function (file) {
+        return options.filePattern.exec(file);
+      });
+
+      callback(null, files);
+    });
+  },
+
+  /**
+   * Attempts to detect whether a session file is already expired or not
+   *
+   * @param  {String}   sessionId
+   * @param  {Object}   options
+   * @param  {Function} callback
+   *
+   * @api public
+   */
+  expired: function (sessionId, options, callback) {
+    helpers.get(sessionId, options, function (err, session) {
+      if (err) return callback(err);
+
+      var ttl = options.ttl * 1000;
+      if (!ttl) {
+        var maxAge = session.cookie ? session.cookie.maxAge : undefined;
+        ttl = 'number' === typeof maxAge ? maxAge : 24 * 60 * 60 * 1000;
+      }
+
+      err ? callback(err) : callback(null, session.__lastAccess + ttl < new Date().getTime());
+    });
+  }
+};
+
+module.exports = helpers;
\ No newline at end of file
Index: lib/reap-worker.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/reap-worker.js	(revision )
+++ lib/reap-worker.js	(revision )
@@ -0,0 +1,14 @@
+var helpers = require('session-file-helpers');
+
+var options = helpers.defaults({
+  path: process.argv[2],
+  ttl: process.argv[3]
+});
+
+if (options.path) {
+  console.log("[session-file-store:worker] Deleting expired sessions");
+  helpers.reap(options);
+} else {
+  console.log("[session-file-store:worker] Reap worker started with invalid path");
+  process.exit(1);
+}
Index: lib/session-file-store.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/session-file-store.js	(revision 373d344f67323660aad17dd05c84b7501e9997e5)
+++ lib/session-file-store.js	(revision )
@@ -1,14 +1,6 @@
-var fs = require('graceful-fs'),
-  path = require('path'),
-  retry = require("retry");
+var helpers = require('session-file-helpers');
 
 /**
- * One day in seconds
- */
-
-var ONE_DAY = 24 * 60 * 60;
-
-/**
  * https://github.com/expressjs/session#session-store-implementation
  *
  * @param {object} session  express session
@@ -22,7 +14,8 @@
   /**
    * Initialize FileStore with the given `options`
    *
-   * @param {Object} options
+   * @param {Object} options (optional)
+   *
    * @api public
    */
   function FileStore(options) {
@@ -31,65 +24,17 @@
     options = options || {};
     Store.call(self, options);
 
-    self.path = path.normalize(options.path || './sessions');
-    self.ttl = options.ttl || 3600;
-    self.retries = options.retries || 5;
-    self.factor = options.factor || 1;
-    self.minTimeout = options.minTimeout || 50;
-    self.maxTimeout = options.maxTimeout || 100;
-
-    self.filePattern = /\.json$/;
-
-    // set default reapInterval to 1 hour
-    self.reapInterval = (options.reapInterval * 1000) || 3600000;
-
-    // interval for reaping old sessions
-    if (self.reapInterval !== -1) {
-      setInterval(function () {
-        self.reap();
-      }, self.reapInterval);
+    self.options = helpers.defaults(options);
+    helpers.createPathIfRequired(self.options);
+    helpers.scheduleReapWorker(self.options);
-    }
+  }
 
-    fs.mkdir(self.path, function (err) {
-      if (err && err.code != 'EEXIST') throw err;
-    });
-  }
-
   /**
    * Inherit from Store
    */
   FileStore.prototype.__proto__ = Store.prototype;
 
   /**
-   Delete sessions older than ttl / maxAge
-   @api private
-   */
-  FileStore.prototype.reap = function () {
-    console.log("[session-file-store] Deleting expired sessions");
-    var self = this;
-    // get session list
-    self.list(function (err, files) {
-      // no error, continue
-      if (err == null) {
-        function destroyIfExpired(sessionId) {
-          //and check if its expired
-          self.expired(sessionId, function (err, expired) {
-            if (err == null && expired) {
-              self.destroy(sessionId, null);
-            }
-          });
-        }
-
-        for (var i = 0; i < files.length; i++) {
-          // get the session id from filename
-          destroyIfExpired(files[i].substring(0, files[i].lastIndexOf('.json')));
-        }
-      }
-    });
-  };
-
-
-  /**
    * Attempts to fetch session from a session file by the given `sessionId`
    *
    * @param  {String}   sessionId
@@ -98,35 +43,7 @@
    * @api public
    */
   FileStore.prototype.get = function (sessionId, callback) {
-    var self = this;
-
-    var sessionPath = path.join(this.path, sessionId + '.json'),
-      json;
-
-    var operation = retry.operation({
-      retries: self.retries,
-      factor: self.factor,
-      minTimeout: self.minTimeout,
-      maxTimeout: self.maxTimeout
-    });
-
-    operation.attempt(function (currentAttempt) {
-      fs.readFile(sessionPath, 'utf8', function (err, data) {
-        if (err) return callback(err);
-
-        try {
-          json = JSON.parse(data);
-        } catch (err) {
-          if (operation.retry(err)) {
-            console.log("[retry] will retry, error on last attempt: " + err);
-            return;
-          }
-          return callback(err);
-        }
-
-        callback(null, json);
-      });
-    });
+    helpers.get(sessionId, this.options, callback);
   };
 
   /**
@@ -134,23 +51,12 @@
    *
    * @param {String}   sessionId
    * @param {Object}   session
-   * @param {Function} callback   optional
+   * @param {Function} callback (optional)
    *
    * @api public
    */
   FileStore.prototype.set = function (sessionId, session, callback) {
-    var self = this;
-
-    try {
-      session.__lastAccess = new Date().getTime();
-      session = JSON.stringify(session);
-
-      fs.writeFile(path.join(self.path, sessionId + '.json'), session, function (err) {
-        callback && err ? callback(err) : callback(null, JSON.parse(session));
-      });
-    } catch (err) {
-      callback && callback(err);
-    }
+    helpers.set(sessionId, session, this.options, callback);
   };
 
   /**
@@ -163,9 +69,7 @@
    * @api public
    */
   FileStore.prototype.destroy = function (sessionId, callback) {
-    fs.unlink(path.join(this.path, sessionId + '.json'), function (err) {
-      if (callback) callback(err);
-    });
+    helpers.destroy(sessionId, this.options, callback);
   };
 
   /**
@@ -176,20 +80,7 @@
    * @api public
    */
   FileStore.prototype.length = function (callback) {
-    var self = this;
-
-    fs.readdir(self.path, function (err, files) {
-      if (err) return callback(err);
-
-      var result = 0;
-      files.forEach(function (file) {
-        if (self.filePattern.exec(file)) {
-          ++result;
-        }
-      });
-
-      callback(null, result);
-    });
+    helpers.length(this.options, callback);
   };
 
   /**
@@ -200,32 +91,7 @@
    * @api public
    */
   FileStore.prototype.clear = function (callback) {
-    var self = this,
-      filePath;
-
-    fs.readdir(self.path, function (err, files) {
-      if (files.length <= 0) return callback();
-
-      var errors = [];
-      files.forEach(function (file, i) {
-        filePath = path.join(self.path, file);
-
-        if (self.filePattern.exec(file)) {
-          fs.unlink(filePath, function (err) {
-            if (err) {
-              errors.push(err);
-            }
-            if (i >= files.length - 1) {
-              callback(errors.length > 0 ? errors : undefined);
-            }
-          });
-        } else {
-          if (i >= files.length - 1) {
-            callback(errors.length > 0 ? errors : undefined);
-          }
-        }
-      });
-    });
+    helpers.clear(this.options, callback);
   };
 
   /**
@@ -236,17 +102,7 @@
    * @api public
    */
   FileStore.prototype.list = function (callback) {
-    var self = this;
-
-    fs.readdir(self.path, function (err, files) {
-      if (err) return callback(err);
-
-      var sessionFiles = files.filter(function (file) {
-        return self.filePattern.exec(file);
-      });
-
-      callback(null, sessionFiles);
-    });
+    helpers.list(this.options, callback);
   };
 
   /**
@@ -258,18 +114,7 @@
    * @api public
    */
   FileStore.prototype.expired = function (sessionId, callback) {
-    var self = this,
-      now = new Date().getTime();
-    self.get(sessionId, function (err, session) {
-      if (err) return callback(err);
-
-      var maxAge = session.cookie.maxAge,
-        ttl = self.ttl * 1000 || ('number' == typeof maxAge
-            ? maxAge | 0
-            : ONE_DAY);
-
-      err ? callback(err) : callback(null, session.__lastAccess + ttl < now);
-    });
+    helpers.expired(sessionId, this.options, callback);
   };
 
   return FileStore;
